# 实验四 使我对虚拟内存的内容和机制有了更加深入的了解，对抽象的使用有了更好的认识

* 通过动态内存分配，提高应用对内存的使用效率，同时通过虚实内存映射机制，简化编译器对应用的地址空间设置，加强了内存隔离，避免了应用直接访问物理内存
* 通过限制应用最大可用内存小于物理内存的容量，从而使多个应用的数据驻留。
* 要完成并完善地址空间设计，仍需要来自计算机硬件的支持，例如MMU 和 TLB 等硬件机制。
* 完成虚实地址转换，需要硬件提供一些寄存器，让软件可以对他进行设置，来控制MMV按照某个应用的地址关系进行地址转换
* 分页式内存管理内核以也为单位进行物理内存管理，每个应用的地址空间被分成若干个虚拟页面，而物理内存也相类似地分成若干个页帧，虚拟页面和物理页帧的大小相同
* 当一个应用的地址空间比较大的时候，页表里面的项数会很多，以至于它的容量极速膨胀，CPU 内也没有 足够的硬件资源能够将它存下来。因此它只能作为一种被内核管理的数据结构放在内存中，但是 CPU 也会直接访问它来查页表， 这就需要内核和硬件之间关于页表的内存布局达成一致
* 在分配页地时候返回值类型并不是 FrameAllocator 要求的物理页号 PhysPageNum ，而是将其 进一步包装为一个 FrameTracker 。这里借用了 RAII 的思想，将一个物理页帧的生命周期绑定到一个 FrameTracker 变量上，只需为 FrameTracker 实现 Drop Trait，当一个 FrameTracker 实例被回收的时候，它的 drop 方法会自动被编译器调用，通过之前实现的 frame_dealloc 我们就将它控制的物理页帧回收以供后续使用了
